#include<iostream>
#include<fstream>
#include"ray.h"
using namespace std;

const int nx = 200;
const int ny = 100;

float max_r = 255.99;
float max_g = 255.99;
float max_b = 255.99;

const vec3 lower_left_corner(-2.0, -1.0, -1.0);
const vec3 horizontal(4.0, 0.0, 0.0);
const vec3 vertical(0.0, 2.0, 0.0);
const vec3 origin(0.0, 0.0, 0.0);

const vec3 tri_1(-1.0, -0.5, -1.0);
const vec3 tri_2(1.0, 0.7, -1.4);
const vec3 tri_3(0.1, -0.3, -1.0);


float hit_sphere(const vec3 &center,const float &radius, const ray &r){
    
    float a = dot(r.direction(),r.direction());
    vec3 oc = r.origin()-center;
    float b = 2*dot(r.direction(), oc);
    float c = dot(oc, oc)-radius*radius;
    float derta = b*b - 4*a*c;
    if (derta<0) return -1.0;
    else return ((-b-sqrt(derta))/(2*a));
}

vec3 hit_tri(const vec3 &v0, const vec3 &v1, const vec3 &v2, const ray &r){
    vec3 E1 = v1 - v0;
    vec3 E2 = v2 - v0;

    vec3 P = cross(r.direction(),E2);
    float det = dot(P, E1);
    
    vec3 T;
    if (det>0)  T = r.origin() - v0;
    else {
        T = v0 - r.origin();
        det = -det;
    }
    if (det < 0.0000001) return vec3(-1.0, 0.0, 0.0);

    float u = dot(P, T);
    float detline = det*0.1;
    if (u< 0 || u > det+detline/5) return vec3(-1.0, 0.0, 0.0);
    
    vec3 Q = cross(T, E1);
    float v = dot(Q, r.direction());
    if (v < 0 || v+u>det) return vec3(-1.0, 0.0, 0.0);
//    if (u < detline) return vec3(-2.0, 0.0, 0.0);
//    if (v < detline) return vec3(-2.0, 0.0, 0.0);
//    else if (v+u > det) return vec3(-2.0, 0.0, 0.0);
    float t = dot(Q, E2);

    float invdet = 1/det;
    return vec3(u*invdet, v*invdet, t*invdet);
}

vec3 color(const ray &r){

    vec3 col_tri = hit_tri(tri_1, tri_2, tri_3, r);
//    if (col_tri.r() == -2.0) return vec3(0.0, 0.0, 0.0);
    if (col_tri.r() >= 0.0) {
        float u = col_tri.g();
        float t = u;
//        return t*vec3(0.25, 0.35, 0.6) + (1-t)*vec3(1, 1, 1);
        return vec3((1-t)*1, 1, 1);
    }


    const vec3 center(0.0,0.0,-1.0);
    float t = hit_sphere(center, 0.5, r);
    if (t>0){
        vec3 op = r.point_at_parameter(t);
       vec3 oc = center;
        vec3 cp = op - oc;
        vec3 unit_cp = unit_vector(cp);
        return 0.5*(unit_cp+1);
    }


    vec3 unit_direction = unit_vector(r.direction());
    float j = 0.5*(unit_direction.y()+1);
    float k = 0.5*(unit_direction.x()+1);
    float l = 0.5*(unit_direction.z()+1);

//   return (1-t)*vec3(0.0, 0.0, 0.0)+t*vec3(0.1, 0.9, 1.0);
    return vec3((1-k)*0.1,(1-j)*0.1,(1-l)*0.1)+vec3(k*1, j*0.5, l*1);
} 


int main(){
    ofstream outfile;
    outfile.open("1.ppm", ios::out);
    outfile<<"P3\n"<<nx<<" "<<ny<<"\n255\n";
    vec3 a(1,1,1);
    vec3 b(0.5,0.5,0.5);
    vec3 c = b - a;
    cout<<c.x()<<c.y()<<c.z();

    for(int j = ny-1; j >= 0; j--){
        for(int i = 0; i <= nx-1; i++){
            float u = float(i)/float(nx);
            float v = float(j)/float(ny);
            ray ray(origin, lower_left_corner+ u*horizontal+ v*vertical);
            vec3 col = color(ray);


            int r = int(max_r * col[0]);
            int g = int(max_g * col[1]);
            int b = int(max_b * col[2]);
            outfile<<r<<" "<<g<<" "<<b<<" ";
        }
        outfile<<endl;
    }





    outfile.close();
}